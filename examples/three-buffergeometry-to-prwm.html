<!doctype html>
<html>
    <head>
        <style>
            html, body {
                padding:0;
                margin:0;
                background:#000000;
            }

            .actions {
                position:absolute;
                left:12px;
                top:10px;
                z-index:2;
                font-family: "Arial", "Helvetica Neue", "Helvetica", sans-serif;
                font-size:13px;
                text-align:left;
                color:#FFFFFF;
            }

            .actions a, .actions a:visited {
                color:#FFFFFF;
                margin-right:12px;
                text-decoration: none;
            }

            .actions a:hover, .actions a:focus {
                text-decoration: underline;
            }

            .notes {
                position:absolute;
                left:12px;
                bottom:10px;
                z-index:2;
                font-family: "Arial", "Helvetica Neue", "Helvetica", sans-serif;
                font-size:13px;
                text-align:left;
                color:#FFFFFF;
                max-width:300px;
            }

            .notes a {
                color:#FFFFFF;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.js"></script>
        <script src="../implementations/three-buffergeometry-to-prwm/build/three-buffergeometry-to-prwm.min.js"></script>
    </head>
    <body>
        <div class="actions">
            <a href="#" id="download">Download as a PRWM file</a>
        </div>
        <div class="notes">
            Generating a PRWM file from an existing WebGL geometry is relatively simple,
            making it a perfect fit for procedurally generated geometries.<br><br>
            In this example the geometry is generated by extruding a shape using the tools built in Three.js.<br><br>

            <a href="https://github.com/kchapelier/PRWM" target="_blank">Specifications and implementations</a>
        </div>
        <script>

            var container;

            var camera, scene, renderer;

            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;


            init();
            animate();


            function init() {
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.z = 250;

                // scene

                scene = new THREE.Scene();

                var ambient = new THREE.AmbientLight( 0x101030 );
                scene.add( ambient );

                var directionalLight = new THREE.DirectionalLight( 0xffeedd );
                directionalLight.position.set( 0, 0, 1 );
                scene.add( directionalLight );

                // model

                var material = new THREE.MeshPhongMaterial({});

                var randomPoints = [];

                for ( var i = 0; i < 8; i ++ ) {

                    randomPoints.push( new THREE.Vector3( ( i - 3.5 ) * 50, THREE.Math.randFloat( - 50, 50 ), THREE.Math.randFloat( - 50, 50 ) ) );

                }

                var randomSpline =  new THREE.CatmullRomCurve3( randomPoints );

                var extrudeSettings = {
                    steps			: 250,
                    bevelEnabled	: false,
                    extrudePath		: randomSpline
                };

                var pts = [], numPts = 5;

                for ( var i = 0; i < numPts * 2; i ++ ) {

                    var l = i % 2 == 1 ? 10 : 20;

                    var a = i / numPts * Math.PI;

                    pts.push( new THREE.Vector2 ( Math.cos( a ) * l, Math.sin( a ) * l ) );

                }

                var shape = new THREE.Shape( pts );

                var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
                var bufferGeometry = new THREE.BufferGeometry().fromGeometry( geometry );

                var mesh = new THREE.Mesh( bufferGeometry, material );

                scene.add( mesh );

                //

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio( 1 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );


                document.getElementById('download').addEventListener('click', function (e) {
                    e.preventDefault();

                    // get the PRWM file content
                    var arrayBuffer = threeBuffergeometryToPrwm(bufferGeometry, false);

                    // download the file
                    var blob = new Blob([arrayBuffer], {type: 'application/binary'});

                    var a = document.createElement('a');
                    a.download = 'extruded-geometry.prwm';
                    a.href = window.URL.createObjectURL(blob);
                    a.textContent = 'download-link';
                    a.style = 'position:absolute;top:-200px;left:-200px;font-size:12px;';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                });
                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onDocumentMouseMove( event ) {

                mouseX = ( event.clientX - windowHalfX ) / 2;
                mouseY = ( event.clientY - windowHalfY ) / 2;

            }

            //

            function animate() {

                requestAnimationFrame( animate );
                render();

            }

            function render() {

                camera.position.x += ( mouseX - camera.position.x ) * .05;
                camera.position.y += ( - mouseY - camera.position.y ) * .05;

                camera.lookAt( scene.position );

                renderer.render( scene, camera );

            }

        </script>
    </body>
</html>
